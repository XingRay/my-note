# Vulkan:同步与Cache控制笔记

> An operation is an arbitrary amount of work to be executed on the host, a device, or an external entity such as a presentation engine. Synchronization commands introduce explicit execution dependencies, and memory dependencies between two sets of operations defined by the command’s two synchronization scopes.

定义一个名为opertion的概念，他是一系列灵活的执行任务。有可能被执行在host或者GPU，或者外部设备例如显示设备。同步指令清晰的规范指定了两个opertaion之间的“执行依赖”以及“内存依赖”，通过去定义对应同步指令的两个同步域(defined by the command’s two synchronization scopes.)。

思考：首先定义了opertion的概念，同步指令的作用是规范两个operation之间的依赖关系，具体是通过同步域(synchronization scopes)来实现的。下文继续介绍，什么是synchronization scopes。

> The synchronization scopes define which other operations a synchronization command is able to create execution dependencies with. Any type of operation that is not in a synchronization command’s synchronization scopes will not be included in the resulting dependency. For example, for many synchronization commands, the synchronization scopes can be limited to just operations executing in specific pipeline stages, which allows other pipeline stages to be excluded from a dependency. Other scoping options are possible, depending on the particular command.

synchronization scopes定义了哪些operation，其对应的synchronization command 可以为其创建execution dependencies。任何不在synchronization command 对应的scopes 里面的operation都不会作用其依赖机制。举个例子，如果有非常多的synchronization commands，他们对应的synchronization scopes只会作用到opertions执行过程中指定的一些pipeline states，这样这个synchronization scopes就不会影响到opertion其他的pipeline states执行过程。

思考，synchronization scopes是pipeline stage的一段范围。

> An execution dependency is a guarantee that for two sets of operations, the first set must happenbefore the second set. If an operation happens-before another operation, then the first operation must complete before the second operation is initiated. More precisely:

一个执行依赖保证了两个opertions的集合，第一个必须执行在第二个之前，如果两个operation同时执行，那么第二个应当等待第一个执行完毕再执行。

定义Ops1 和Ops2作为两个operation集合

定义Sync作为synchronization cmooand

定义Scope1st 与Scope2st作为Sync的同步域，是一段pipeline stage范围。

ScopedOps1是Ops1与Scope1st的交集

ScopedOps2是Ops2与Scope2st的交集

提交Ops1,Sync,Ops2，运行之后，会在ScopedOps1和ScopedOps2之间产生一个ExeDep

这个ExeDep会保证ScopedOps1发生在ScopedOps2之前

> Execution dependencies alone are not sufficient to guarantee that values resulting from writes in one set of operations can be read from another set of operations.

执行依赖并不能有效的保证，上一次operation的写入可以正确的被下一次operation的读出。

> Three additional types of operations are used to control memory access. Availability operations cause the values generated by specified memory write accesses to become available to a memory domain for future access. Any available value remains available until a subsequent write to the same memory location occurs (whether it is made available or not) or the memory is freed. Memory domain operations cause writes that are available to a source memory domain to become available to a destination memory domain (an example of this is making writes available to the host domain available to the device domain). Visibility operations cause values available to a memory domain to become visible to specified memory accesses.

存在三种用作内存[访问控制](https://zhida.zhihu.com/search?content_id=227794917&content_type=Article&match_order=1&q=访问控制&zhida_source=entity)的operations

1. Availability operations : 保证写入的内存是可用的，在未来其他区域的core可以访问。任何一个available值始终会保持可用，直到下一次操作写入相同的地址新的数据，或者memory被free。
2. Memory domain operations：写操作由sources memory domain可用，转变为对destination memory domain可用（举个例子，可以将这次写操作，从host domain available 转变为device domain available）
3. Visibility operations:Visibility operations cause values available to a memory domain to become visible to specified memory accesses

**Availability** **visibility**, **memory domains**, and **memory domain operations** are formally defined in the *Availability and Visibility* section of the *Memory Model chapter*

。