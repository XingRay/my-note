## 缓存的穿透、雪崩与击穿

### 1.缓存穿透

#### 1.1问题的产生

查询一个数据库中不存在（数据库返回null）的数据，由于这个数据不存在因而没有在缓存中存储，那么会导致每次请求时，先查询缓存，由于缓存不存在，再去请求数据库，而数据库每次查询又都是null，也没有将这次的结果null存入缓存，导致每次请求都会请求到数据库，缓存失去了作用。

#### 1.2 风险

攻击者利用一个一定不存在的数据进行大量的请求，导致数据库压力瞬间增大，导致数据库崩溃进而系统崩溃。

#### 1.3 解决办法

将null值也存入缓存，并且加上过期时间



### 2.缓存雪崩

#### 2.1 产生原因

如果缓存中存放了大量的数据，而且大量的不同的key的过期时间一致，那么可能会导致某个瞬间大量的缓存的key失效，大量的请求发送到数据库，导致数据库崩溃。

#### 2.2 解决办法

在原有的失效时间基础上加一个随机值，比如 1-5分钟的随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效事件



### 3.缓存击穿

#### 3.1 产生原因

对于一些设置了过期时间的key，如果这些key可能会在某个时间点被超高并发访问，是一种非常热点的数据，如果这个key在大量请求来之前正好失效，那么所有对于这个key的查询请求到转到了数据库，这种情况称为缓存击穿。

#### 3.2 解决办法

加锁（分布式锁）

大并发来时只让一个线程去查数据库，其他的线程（包括其他实例上的线程）等待，查到存入缓存后释放锁，其他线程再去访问就能查询到缓存，不需要再去访问数据库。



### 4.代码实现

```java
// 从缓存中加载数据
// 1.空结果缓存，解决缓存穿透
// 2. 设置过期时间，并且加上随机值，放置缓存雪崩
// 3. 加上分布式锁，解决缓存击穿

getData(key){
    data = cache.load(key);
    if(data == null){
    	lock.lock();
		data = cache.load(key);
    	if(data == null){
            data = db.load(key);
            if(data == null){
                cache.put(key, "my-custom-cache-null", expireTime + random);
            }else{
                cache.put(key, data, expireTime + random);
            }
    	}
        lock.unlock();
    }
    return data;    
}
```

