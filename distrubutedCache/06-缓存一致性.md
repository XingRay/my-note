## 缓存一致性

数据库中的数据更新后，缓存的数据如何同步的问题，就是缓存一致性问题。

### 1.双写模式

![image-20230504180746284](D:\myNote\resources\image-20230504180746284.png)

双写模式就是每次更新数据时紧接着又更新缓存，但是存在问题：

1.线程1更新数据为1

2.线程2更新数据为2

3.线程2更新缓存为2

4.线程1更新缓存为1

此时从缓存中读取的数据为1，但是最后更新数据库的数据为2，因此出现脏数据。

解决办法：

1.加锁，写数据库写缓存整体加上锁

2.看业务是否允许脏数据的存在，比如商品描述、分类等，**给缓存设置过期时间**，过期之后缓存失效，再此查询就可以自动更新到最新数据了。



### 2.失效模式

![image-20230504184451383](D:\myNote\resources\image-20230504184451383.png)

失效模式就是每次更新数据后删除缓存，下次查询数据时查询数据库再设置上缓存，失效模式也存在问题，考虑下列情况：

1.线程1写如数据1，删除缓存

2.线程2执行业务流程，准备写入数据库，但是还没有写入

3.线程3读取缓存，由于步骤1中，线程1删除了缓存，缓存不存在，线程3读取数据库，此时数据库中数据还是1，线程3读取到数据1，准备更新缓存，但是还没有写入

4.线程2将数据2写入数据库，此时数据库的数据为2，线程2删除缓存

5.线程3将数据1写入缓存

此时缓存中的数据为1，但是数据库中的数据为2，**数据不一致**



解决办法：

1. 加锁，可以考虑加读写锁，但是加锁会影响性能
2. 如果数据经常修改，加锁会严重影响性能，可以考虑不要缓存，直接读取数据库。



上述两个模式中缓存都设置了过期时间，因此都能具备**最终一致性**，不是强一致，实时一致。



### 3.缓存数据一致性-解决方案

无论是双写模式还是失效模式，都会导致缓存的不一致问题，即多个实例同时更新时会产生数据不一致，处理办法：

1. 如果是用户维度的数据（订单数据、用户数据），这种并发几率小，不用考虑这个问题，缓存数据加上过期时间，每个一段时间触发读数据主动更新即可。
2. 如果是菜单，商品介绍等基础数据，也可以使用cannal订阅binlog的方式
3. 缓存数据+过期时间也足够解决大部分业务对于缓存的要求
4. 通过加读写锁保证并发读写，写写的时候按顺序排队。读读并发不用竞争锁。所以适合使用读写锁。业务不考虑脏数据，可以容忍临时的脏数据可忽略，不加锁。



cannal：

使用cannal更新缓存

![image-20230504191128062](D:\myNote\resources\image-20230504191128062.png)



使用cannal解决数据异构问题：

![image-20230504191222392](D:\myNote\resources\image-20230504191222392.png)



### 4.总结

1.放入缓存的数据本来就是不能是实时性、一致性要求很高的数据。所以缓存上加上过期时间，保证最终一致性，即每天可以拿到最终数据即可。

2.不应该过度设计，增加系统的复杂度

3.遇到实时性、一致性要求高的数据，就应该直接查询数据库，即使耗时较长。

