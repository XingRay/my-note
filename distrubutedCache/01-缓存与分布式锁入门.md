## 缓存与分布式锁

### 1.缓存



#### 1.1 缓存的基本概念

为了系统性能的提升，一般会将部分数据放入缓存中，加速访问

哪些数据适合放入缓存：

1. 即时性和数据一致性要求不高
2. 访问量大，更新频率不高（读多，写少）



这里数据一致性指：系统读出的数据与数据库中的数据是否一致？

比如：数据库中修改了商品分类，但是缓存中没有修改，就叫做不一致。这种业务数据可能对于一致性的要求不高，不高不是不要一致性，而是不要求很快达到一致性。比如在电商类应用，商品分类、商品列表等适合缓存并加一个失效时间，后台如果发布一个商品，买家需要5分钟才能看到新的商品一般还是可以接受的。



![image-20230503140216789](D:\myNote\resources\image-20230503140216789.png)



```java
// 从缓存中加载数据
getData(key){
    data = cache.load(key)
    if(data==null){
        data = db.load(key);
        cache.put(key, data);
    }
    return data;
}
```

注意：在开发中，凡是放入缓存的数据都应该指定过期时间，使其可以在系统即使没有主动更新数据也能自动触发加载最新数据进入缓存的流程，避免因为业务崩溃导致的数据永久不一致的问题。



#### 1.2 本地缓存

![image-20230503192415312](D:\myNote\resources\image-20230503192415312.png)

最简单的缓存可以使用一个Map来实现，如HashMap，ConcurrentHashMap，简单示例如下：

```java
Map<Long, Object> chache = new HashMap<>();
// ...

getData(key){
    data = cache.get(key)
    if(data==null){
        data = db.load(key);
        cache.put(key, data);
    }
    return data;
}
```

本地缓存在单机运行环境下是可以使用的，但是在微服务、分布式环境下是有问题的。



![image-20230503191957456](D:\myNote\resources\image-20230503191957456.png)

多个实例在读取的时候只能读取各自的缓存，问题不大，但是当一个实例将数据修改，那么其他的实例将读取到数据将会与修改数据的实例读取到的数据不一致。这就产生了**一致性**的问题。



#### 1.3 分布式缓存

将缓存统一集中到缓存中间件存储，如redis，单台redis服务性能不够可以以集群模式工作，也可以做分片存储。打破容量限制，做到高可用，高性能。

![image-20230503192630051](D:\myNote\resources\image-20230503192630051.png)



